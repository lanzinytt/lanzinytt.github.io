---
layout:     post
title:      "计算机组成原理复习要点整理.25"
subtitle:   " \"Computer Organization and Architecture\""
date:       2025-12-16 20:00:00
author:     "LanZinYtt"
header-img: "img/in-post/Computer_Organization_and_Architecture/Computer_Organization_and_Architecture_header_2.jpg"
catalog: true
tags:
    - Computer_Science_Specialized_Courses
    - Principles_of_Computer_Composition
---

# 计算机组成原理

## 第一章：计算机系统概述

1. 计算机发展历史
    1. 从第一代到第四代计算机各自的主要特点
        - 第一代采用电子管元件。
        - 第二代采用晶体管元件，磁芯作内存，磁鼓、磁带作外存等。
        - 第三代采用中小规模集成电路，半导体存储器作内存，出现了微程序控制，Cache，虚拟存储器，流水线等技术。IBM公司提出了“兼容机”的概念，DEC公司提出了总线结构。 
        - 第四代采用大规模/超大规模集成电路，出现了微处理器，出现了共享存储器，分布式存储器及大规模并行处理系统等技术。
    2. `**冯·诺依曼结构的主要基本思想**`
        1. **采用“存储程序”的工作方式。**
        2. 计算机由**运算器、控制器、存储器、输入设备和输出设备**5个基本部件组成。
        3. 存储器不仅能存放数据，而且也能存放指令，形式上数据和指令没有区别，但计算机应能区分它们；控制器应能控制指令的自动执行；运算器应能进行加、减、乘、除4种基本算术运算，并且也能进行逻辑运算；操作人员可以通过输入/输出设备使用计算机。
        4. 计算机内部以**二进制**形式表示指令和数据；每条指令由操作码和地址码两部分组成，操作码指出操作类型，地址码指出操作数的地址；由一串指令组成程序。
2. 计算机系统的基本组成
    1. 现代计算机结构模型的基本构成及其执行程序（指令序列）的步骤
    2. 指令与数据
    3. 系统软件和应用软件
        - 系统软件包括为有效、安全地使用和管理计算机以及为开发和运行应用软件而提供的各种软件，介于计算机硬件与应用软件之间，它与具体应用关系不大。
        - 面向用户的应用软件。
3. 计算机系统的层次结构
    - ![alt text](/img/in-post/Computer_Organization_and_Architecture/The_hierarchy_of_computer_systems.png)
    1. 现代计算机系统中从硬件、ISA，到操作系统、语言处理系统和应用程序的层次结构。（如上图）
    2. 最终用户、应用程序员、系统管理员、系统程序员分别工作的层面。（如上图）
    3.  ISA涉及的主要内容
        - 是软件和硬件之间接口的一个完整定义
        - 定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，所处理的操作数所存放的位置以及操作数的类型等
4. 计算机系统性能评价
    1. **具体的性能评价名词**：
        - **响应时间**：也称为执行时间(executiontime)或等待时间(latency),是指从作业提交开始到作业完成所用的时间。
        - **吞吐率**：表示在单位时间内所完成的工作量。
        - `**CPU时间**`
            - 用户感觉到的执行时间分成用户CPU时间和其他时间
            - **用户CPU时间**
                - 真正用于用户程序代码的执行时间
                - **用户CPU时间与CPU性能直接挂钩**
                    - 计算机系统的性能主要考虑的是CPU性能
                    - 系统性能和CPU性能不等价
            - 其他时间
                - CPU运行操作系统程序的时间
                - 等待I/O操作完成的时间或CPU用于其他用户程序的执行时间。
        - **MIPS**： 表示平均每秒钟执行多少百万条指令。
        - **MFLOPS**： 表示每秒钟所执行的浮点运算有多少百万次，它是基于所完成的操作次数而不是指令数来衡量的。
        - 基准程序（Benchmarks）     
    2. **CPI的计算**
        - 程序的综合CPI也可由以下公式求得，其中 $F_i$ 表示第 $i$ 种指令在程序中所占的比例：
        - $$ \mathrm{CPI} = \sum_{i=1}^{n} (\mathrm{CPI}_i \times F_i) = \frac{\text{程序总时钟周期数}}{\text{程序总指令条数}} $$
    3. 阿姆达尔定律及简单应用
        - 阿姆达尔定律定义了增强或加速部分部件而获得的整体性能的改进程度：
        - 改进后的执行时间=改进部分执行时间÷改进部分的改进倍数+未改进部分执行时间
## 第二章：数据的机器级表示

1. 数值数据的表示
    1. 定点数的表示
        1. 原码补码移码
            - 二进制原码、补码的表示必须搞清楚；
            - 移码表示：标准移码的偏置常数2n-1，它与补码的关系：最高位相反，其余位相同。
        2. 无符号数表示和带符号数表示进行数据长度扩展时的差异。
            - 零扩展和符号扩展
    2. **浮点数表示IEEE754标准**
        1. 单精度32位和双精度64位的格式；偏置常数的取值。
            - ![alt text](/img/in-post/Computer_Organization_and_Architecture/Floating-point_representation.png)
            - 单精度和双精度浮点数的偏置常数分别为127和1023，并且都规定隐藏位1的位置在小数点之前。
        2. 规格化数的阶码取值范围；规格化尾数的表示（隐含位1）；IEEE754浮点数几个特殊数据的表示形式：0、∞、NaN(非数)、非规格化数。
            - ![alt text](/img/in-post/Computer_Organization_and_Architecture/Floating-Point_Value_Table.png)
        3. 了解用ASCII码表示十进制数：前分隔数字串和后嵌入数字串两种格式表示正负号；用BCD码表示十进制数：正负数的表示方法，位数不等于8Bit的整数倍时需补0。
2. 非数值数据的表示
    - 汉字的编码
        - 输入码
        - 内码：GB 2312 国标字符集
        - 字模点阵码： 字形信息库
3. 数据的宽度，存储和排列顺序
    1. 概念：字、字长、最低有效字节LSB、最高有效字节MSB
    2. 数据按字节存储时，多字节数据的地址涉及到数据是大端方式还是小端方式。
    3. 指令存放时大端和小端只影响指令中的多字节常数，不影响其他字段的存放顺序。
    4. 数据存储时存在边界对齐和不对齐问题，它们在存储空间和访问速度上存在差异
4. 数据的检错与纠错
    - 常用的数据校验编码：奇偶校验码、海明校验码和循环冗余校验码
    - 掌握奇偶校验码的实现方法
    - 了解数据检错与纠错的基本原理
## 第三章：运算方法和运算部件
1. 串行进位加法器与并行进位加法器 
    1. 并行进位加法器比串行进位加法器速度快的原因。
    2. 全先行进位加法器、局部先行进位加法器和多级先行进位加法器的区别。
2. **ALU的构成**
    1. 整数加减运算器的基本构成（关键:如何实现减法运算）；
        - 使用减数按位取反作为模运算下的减法
    2. ALU如何控制实现加、减、与、或等等各种功能；
    3. ALU的OF、SF、CF和ZF标志信息如何产生。
        - **OF（溢出标志，Overflow Flag）** ：表示有符号数运算结果是否溢出。  
            - 加法：当两个操作数符号相同，结果符号与操作数不同，则溢出。  
            - 公式：  
                $$
                \text{OF} = (A_{n-1} = B_{n-1}) \land (S_{n-1} \neq A_{n-1})
                $$
                其中 $A_{n-1}$、$B_{n-1}$、$S_{n-1}$ 分别为操作数A、B和结果S的最高位（符号位）。

        - **SF（符号标志，Sign Flag）** ：结果的最高位（符号位），反映结果是正还是负。  
            - 公式：  
                $$
                \text{SF} = S_{n-1}
                $$

        - **CF（进位标志，Carry Flag）**  ：表示无符号数运算时最高位是否有进位（加法）或借位（减法）。  
            - 加法：结果产生了第 $n$ 位进位时，CF=1。  
            - 减法：被减数不够减时，CF=1。  
            - 公式（加法）：  
                $$
                \text{CF} = \text{第}~n~\text{位进位}
                $$

        - **ZF（零标志，Zero Flag）**  ：结果是否为零。  
            - 公式：  
                $$
                \text{ZF} = 
                \begin{cases}
                1, & \text{若}~S=0 \\
                0, & \text{若}~S\neq 0
                \end{cases}
                $$

    4. 如何判断无符号数和带符号数加减运算时发生溢出。
        - **无符号数加法溢出**  
            判断CF（进位标志）：  
            - 若CF=1，则发生溢出。  
        - **带符号数加法溢出**  
            判断OF（溢出标志）：  
            - 若两个操作数符号相同，结果符号不同，则溢出。
3. **`定点数的加减乘法运算方法`**
    1. 补码、原码、移码的加减运算方法；
        - 补码加减运算
            - 若两个补码表示的 $n$ 位定点整数为
            $
            [x]_{补} = X_{n-1}X_{n-2}\cdots X_0,\quad [y]_{补} = Y_{n-1}Y_{n-2}\cdots Y_0 $
            则 $[x+y]_{补} $ 和 $[x-y]_{补} $ 的运算表达式如下：

            $
            \begin{aligned}
            [x + y]_{补} &= [x]_{补} + [y]_{补} \pmod{2^n} \\\\
            [x - y]_{补} &= [x]_{补} + [-y]_{补} \pmod{2^n}
            \end{aligned}
            $

             $[-y]_{补}$ 表示 $y$ 的补码表示的负数。
    2. 标准移码与IEEE754移码的加减运算方法的差别；
    3. 无符号数乘法的机器实现基本步骤；
        - 无符号整数乘法运算: ![alt text](/img/in-post/Computer_Organization_and_Architecture/Unsigned_integer_multiplication.png)
    4. 无符号数乘法的硬件逻辑结构；
        - ![alt text](/img/in-post/Computer_Organization_and_Architecture/Unsigned_multiplication.png)
    5. 原码一位乘法机器实现的基本原理。
        - **`原码乘法算法`**(包括二位布斯，布斯不一定考): ![alt text](/img/in-post/Computer_Organization_and_Architecture/Signed_Binary_Multiplication_Algorithm.png)
4. 浮点数运算
    1.	浮点数加减运算的对阶原则和方法；
        - 运算规则： ![alt text](/img/in-post/Computer_Organization_and_Architecture/Floating-point_calculation_method.png)
    2.	如何计算移码表示的阶码的和与差（标准移码与IEEE754移码有什么差别）；
    3.	如何计算一个移码数减1
    4.	尾数规格化中的右规和左规方法；
    5.	尾数的舍入处理常用方法；
    6.	如何判断结果溢出（上溢和下溢）。
        - 在阶码运算与尾码运算时能传递体现。

## 第四章：指令系统
1. 指令系统设计
    1. 指令中包含的字段：
        - 操作码字段（Opcode）：指定操作的类型。
        - 源操作数字段：指定源操作数或其地址。
        - 目标操作数字段：指定结果存放的位置或目标操作数。
        - 地址字段：用于寻址操作数或结果的存储位置。
        - 寻址方式字段：指定操作数的寻址方式。
        - 条件码字段（如有）：用于条件转移等指令。

    2. 提供操作数或操作数地址的方式（**常见寻址方式**）：
        -  ![alt text](/img/in-post/Computer_Organization_and_Architecture/Algorithms_of_Basic_Addressing_Modes_and_Their_Advantages_and_Disadvantages.png)
    3. 指令格式设计的基本原则：
        - 简洁性：指令格式应尽量简洁，便于译码和实现。
        - 灵活性：能支持多种寻址方式和操作类型。
        - 扩展性：便于将来扩展新的指令或功能。
        - 兼容性：考虑与已有指令系统的兼容。
        - 高效性：便于实现高效的指令执行和流水线处理。

    4. 变长操作码编码方法的基本原理：
        - 采用不同长度的操作码，对常用指令分配较短的操作码，不常用指令分配较长的操作码，从而提高编码效率和指令密度。

    5. 条件码的产生与应用：
        - 条件码由ALU等部件在运算过程中产生，如零标志（ZF）、进位标志（CF）、溢出标志（OF）、符号标志（SF）等。
        - 条件码的应用：
            - 无符号数大小比较：通过进位标志（CF）判断。
            - 带符号数大小比较：通过溢出标志（OF）和符号标志（SF）组合判断。

    6. 四种指令格式风格的操作过程和特点：
        - 堆栈型：操作数隐含在栈顶，指令简短，适合表达式求值，硬件实现简单，但访问灵活性差。
        - 累加器型：一个操作数隐含在累加器中，指令长度较短，适合简单运算，数据流不灵活。
        - 通用寄存器型：操作数在多个通用寄存器中，指令灵活，效率高，现代CPU常用。
        - 装入/存储型（Load/Store型）：只有特定指令（如Load/Store）能访问内存，其他运算只在寄存器间进行，便于流水线和并行处理。

    7. CISC和RISC两类指令的特点：
        - CISC（复杂指令集计算机）：指令种类多，功能强大，指令长度不固定，适合复杂操作，硬件实现复杂。
        - RISC（精简指令集计算机）：指令种类少，功能单一，指令长度固定，执行速度快，便于流水线实现，硬件简单。

    8. CISC指令系统的2/8规律：
        - 80%的程序执行时间由20%的指令完成，即大部分程序运行依赖于少数常用指令。
2. 程序的机器级表示
    1. MIPS指令的寻址方式及特点：
        - MIPS支持的寻址方式包括：立即寻址、寄存器寻址、基址寻址（偏移寻址）、PC相对寻址、伪直接寻址。
        - 基址寻址（如 lw、sw 指令）和伪直接寻址（如 j、jal 指令）是MIPS的特有或典型寻址方式。
        - MIPS的基本汇编指令表示为：操作码+目标寄存器+源寄存器+立即数/偏移量/地址等。

    2. MIPS计算机的三种指令格式：
        - R型（Register）：用于寄存器间的运算，操作数和结果均在寄存器中。
        - I型（Immediate）：用于包含立即数、访问内存、分支等，包含一个立即数或偏移量。
        - J型（Jump）：用于跳转指令，包含目标地址。

    3. RR型指令、移位指令、寄存器跳转指令的区别和特点：
        - RR型指令（如 add、sub）：两个源寄存器和一个目标寄存器，操作数和结果均在寄存器中，采用寄存器寻址。
        - 移位指令（如 sll、srl）：一个源寄存器、一个目标寄存器和一个移位量，移位量为指令中的立即数。
        - 寄存器跳转指令（如 jr）：跳转目标地址存放在寄存器中，常用于函数返回。

    4. R型指令采用的寻址方式：
        - R型指令采用寄存器寻址方式，所有操作数和结果均在寄存器中。

    5. I型指令的寻址方式及类型：
        - I型指令可能出现寄存器寻址、立即数寻址、相对寻址和偏移寻址（基址寻址）。
        - 这些寻址方式不会在每条I型指令中同时出现，而是根据指令类型选择。
        - I型指令包括双目运算（如 addi）、分支（如 beq、bne）、存储访问（如 lw、sw）等类型。
        - 分支型和存储访问型指令的地址形成方法：分支型采用PC相对寻址，存储访问型采用基址加偏移寻址。
        - 双目运算型指令中对立即数的扩展方法：对符号位进行符号扩展。

    6. J型指令的寻址方式及功能：
        - J型指令采用伪直接寻址方式，即将指令中的目标地址与当前PC高位拼接形成完整跳转地址。
        - J（jump）指令实现无条件跳转，Jal（jump and link）指令实现跳转并将返回地址保存到$ra寄存器。

    7. 高级语言与汇编指令之间的转换：
        - 基本的运算表达式、if语句、循环、数组访问等高级语言结构都可以通过MIPS汇编指令实现，需掌握其基本转换方法。

    8. RISC-V指令系统模块化结构的特点及压缩指令格式：
        - RISC-V指令系统采用模块化设计，基础指令集可扩展，便于不同应用场景的定制。
        - 16位RISC-V压缩指令与32位RISC-V指令格式相比，压缩指令长度更短，编码更紧凑，适合嵌入式和存储受限场景，但功能覆盖面较窄；32位指令格式功能更全，适合通用处理器。
## 第五章：中央处理器

1. 单周期数据通路的设计
    1. 操作元件和存储元件的概念：
        - 操作元件是指能够对数据进行算术或逻辑运算的部件，如ALU（算术逻辑单元）、加法器、移位器等。
        - 存储元件是指能够存储数据或指令的部件，如寄存器、寄存器组、存储器（内存）等。
    2. 单周期MIPS计算机中的操作元件和存储元件结构图
        - **`完整的数据通路`**：![alt text](/img/in-post/Computer_Organization_and_Architecture/Complete_data_path.png)
    3. 寄存器和寄存器组、理想存储器的读写过程及区别：
        - 寄存器是单个存储单元，寄存器组是多个寄存器的集合，通常支持多端口读写。
        - 理想存储器的读过程：给定地址，经过一个时钟周期后，数据输出到数据总线上。
        - 理想存储器的写过程：给定地址和数据，在时钟上升沿将数据写入指定地址。
        - 区别：寄存器组通常支持更快的访问速度和多端口操作，存储容量较小；理想存储器容量大但访问速度相对较慢，通常为单端口或双端口。
    4. 最基本的7条指令执行时数据通路中信息的流动过程，以及在取指令部件中的信息处理，包括元件的连接和所需要的各种控制信号的取值等。同时也能够在前述基本结构上扩展指定功能和格式的一些简单指令。
        - **`各指令的控制信号取值`**：![alt text](/img/in-post/Computer_Organization_and_Architecture/Control_signal_values_for_each_instruction.png)
2. 单周期控制器的设计

   1. 运算器的功能控制与指令译码原理：
      - 运算器的功能由控制信号决定，控制信号由指令的操作码（OP）和功能码（func）译码产生。
      - OP字段决定指令的基本类型，func字段进一步区分R型指令的具体操作。
      - 每个控制信号与指令译码有一一对应关系，确保数据通路正确执行指令功能。

   2. **单周期CPU周期长度的决定因素**：
      - 单周期CPU的周期长度由执行时间最长的指令决定。
      - 影响因素包括各部件的延迟（如ALU、存储器、寄存器组等），以及存储元件的setup time、hold time和clock to Q time。
      - 通过分析每条指令的执行过程和信息流动路径，确定最短安全时钟周期。

   3. 多周期处理器设计的基本思想：
      - 多周期处理器将指令执行过程分为多个阶段，每个阶段用一个时钟周期完成。
      - 不同指令可在不同周期数内完成，提高了时钟频率和资源利用率。
      - 通过控制信号在每个周期选择不同的数据通路和操作，实现指令的分阶段执行。

3. 微程序控制原理

   1. 微程序控制器的基本思想：
      - 用存储在控制存储器中的微程序（微指令序列）来产生控制信号，控制CPU各部件的操作。
      - 每条机器指令对应一段微程序，微程序由若干微指令组成。

   2. 硬连线控制器和微程序控制器的优缺点比较：
      - 硬连线控制器：速度快，结构复杂，修改和扩展困难，适合指令系统简单的CPU。
      - 微程序控制器：结构灵活，易于修改和扩展，适合指令系统复杂的CPU，但速度较慢。

   3. 指令、微程序、微指令、微命令、微操作的关系：
      - 一条机器指令对应一段微程序。
      - 微程序由若干微指令组成，每条微指令包含多个微命令。
      - 微命令控制具体的微操作（如数据传送、寄存器读写等）。

   4. 水平型微指令和垂直型微指令的概念：
      - 水平型微指令：每条微指令包含多个并行的微命令，控制信号多，执行速度快，编码长度长。
      - 垂直型微指令：每条微指令只包含一个或少数几个微命令，控制信号少，编码长度短，执行速度较慢。

4. 异常和中断处理

   1. 异常和中断（外部）的区别：
      - 异常是由指令执行过程中内部事件引起的（如溢出、非法操作码），中断是由外部设备或外部事件引起的（如I/O完成、时钟中断）。

   2. 计算机中对异常/中断的软件识别和硬件识别的基本过程：
      - 软件识别：通过指令执行结果或状态寄存器中的标志位，由操作系统或异常处理程序检测和处理异常/中断。
      - 硬件识别：由硬件电路直接检测到异常/中断事件，自动转移到相应的中断/异常服务程序入口，保存现场并处理中断/异常。

## 第六章：指令流水线
1. 流水线数据通路和控制

    1. 单周期CPU、多周期CPU与流水线CPU的性能比较：
    - 单周期CPU的时钟周期由执行时间最长的指令决定，所有指令在一个时钟周期内完成。
    - 多周期CPU的时钟周期由各功能部件的最短操作时间决定，不同指令可用不同周期数完成，提高了资源利用率。
    - 流水线CPU的时钟周期由各流水段中最长的功能部件决定，多个指令可在不同阶段并行执行。
    - 流水线方式下，单条指令的执行时间并未缩短，但由于多条指令可以重叠执行，极大提高了指令吞吐率。

    2. 有利于流水线执行的指令集特征（四个特征）：
    - 指令长度固定，便于译码和分段。
    - 寻址方式简单，减少译码和执行复杂度。
    - 操作数位置规则，便于硬件实现流水线。
    - 指令执行时间均衡，避免流水段负载不均。

    3. 常见7条指令的各个流水阶段划分及功能部件分析：
    - **`典型五阶段流水线包括`**：取指（IF）、译码（ID）、执行（EX）、访存（MEM）、写回（WB）。
    - 每条指令在各阶段使用的功能部件不同，如ALU、寄存器组、数据存储器等。
    - 流水线执行情况举例：![alt text](/img/in-post/Computer_Organization_and_Architecture/Example_of_assembly_line execution.png)

    4. 流水段寄存器的作用及长度分析：
    - 流水段寄存器用于在各流水段之间传递数据和控制信息，实现各阶段的隔离。
    - 各流水段寄存器长度不一定相同，取决于需要传递的信息量。
    - 在五阶段流水线中，不同指令在各流水段寄存器中存储的信息包括指令本身、操作数、计算结果、目标寄存器号等。

2. 流水线冒险处理

    1. 流水线冒险的定义及类型：
        - 流水线冒险是指由于资源冲突或数据依赖导致流水线不能正常推进的现象。
        - 分为结构冒险、数据冒险和控制冒险三类。

    2. 结构冒险的现象及处理方法：
        - 结构冒险是指多个流水段同时需要同一硬件资源（如存储器或ALU）。
        - **处理方法**
            - 功能段划分原则(一个部件每条指令只能使用一次，且只能在特定时钟周期使用)
            - 设置多个独立的部件来避免硬件资源冲突

    3. 数据冒险的现象及处理方法：
        - 数据冒险是指指令间存在数据依赖，后续指令需要前面指令尚未写回的结果。
        - **处理方法**
            - 插入空操作 
            - 指令插入气泡
            - 采用转发技术
            - 编译优化
    

    4. 控制冒险的现象及处理方法：
        - 控制冒险是由于分支指令导致流水线取指方向不确定。
        - **处理方法**
            - 简单预测+插入气泡和插入空操作指令
            - 动态预测+插入气泡和插入空操作指令
        
    5. 控制冒险延迟损失时间片计算与优化：
        - 延迟损失时间片C等于分支确定前已进入流水线的指令数。
        - 减少分支延迟的方法包括分支延迟槽、分支预测等。

    6. 分支指令预测方法及预测准确率计算：
        - 静态分支预测：如总是预测不跳转或总是预测跳转。
        - 1位动态分支预测：记录上一次分支结果，预测下一次。
        - 2位动态分支预测：采用两位状态机，提高预测准确率。
        - 预测准确率可通过统计预测正确的分支次数与总分支次数的比值计算。

    7. 异常和中断导致控制冒险的原因：
        - 异常和中断会打断正常的指令流，导致流水线中部分指令需要清空或重启，产生控制冒险。

3. 高级流水线技术

    1. 超流水线的基本原理：
        - 超流水线通过进一步细分流水段，缩短每个流水段的时钟周期，提高指令吞吐率。

    2. 静态多发射的基本原理：
        - 静态多发射（如VLIW）在编译阶段确定每个周期可并行发射的多条指令，硬件结构简单，依赖编译器调度。

    3. 动态多发射的基本原理：
        - 动态多发射（如超标量）由硬件在运行时动态分析指令间依赖，决定每周期可并行发射的指令数，硬件复杂但适应性强。
## 第七章：存储器分层体系结构

1. 存储器概述和存储器芯片

    1. 各类存储器的含义：
        - 随机存取存储器（RAM）：可在任意地址进行读写操作，访问速度快。
        - 顺序存取存储器：数据按固定顺序读写，如磁带。
        - 直接存取存储器：可按地址直接访问数据，但寻址时间与位置有关，如磁盘。
        - 相联存储器：通过内容而非地址访问数据，常用于cache和TLB。
        - 只读存储器（ROM）：只能读不能写，内容在制造时写入。
        - 读写存储器：既可读也可写，如RAM。
        - 非易失性存储器：断电后数据不丢失，如ROM、闪存。
        - 易失性存储器：断电后数据丢失，如DRAM、SRAM。
        - 静态存储器（SRAM）：利用触发器存储数据，速度快，功耗高，容量小。
        - 动态存储器（DRAM）：利用电容存储数据，需定期刷新，速度慢，容量大，功耗低。

    2. 层次结构存储系统各层的特点：
        - 寄存器：位于CPU内部，速度最快，容量最小，成本最高。
        - 高速缓存（Cache）：位于CPU与主存之间，速度快，容量小，成本高。
        - 内存（主存）：容量较大，速度较慢，成本较低。
        - 外存：如磁盘，容量最大，速度最慢，成本最低。
        - 各层存储器与上述各类存储器的对应关系：寄存器和Cache多用SRAM，主存用DRAM，外存用非易失性存储器。

    3. 静态存储器和动态存储器的工作机制：
        - 静态存储器利用触发器存储数据，无需刷新，数据稳定。
        - 动态存储器利用电容存储数据，需定期刷新以防数据丢失。
        - 动态存储器的刷新分为按行刷新、集中刷新、分散刷新和异步刷新。
        - 最大刷新周期由电容漏电特性决定，需保证数据不丢失。
        - 刷新操作与正常访存可交错进行或分时进行。

    4. SDRAM芯片的突发传输方式：
        - SDRAM支持突发传输，即一次启动后可连续传输多个数据，提高带宽和效率。

2. 存储器容量的扩展及其与CPU的连接

    1. 存储器容量扩展方式：
        - 位扩展：增加芯片的位宽，扩展数据总线宽度。
        - 字扩展：增加芯片的字数，扩展地址总线宽度。
        - 字位扩展：同时扩展位宽和字数。
        - 系统存储容量和芯片数的计算需根据扩展方式确定。
        - 芯片组与片选信号的地址线分配、各芯片组的地址范围需合理划分。

3. **`高速缓冲存储器`**（Cache）

    1. **三种映射方式的映射关系**：
        - 直接映射：主存每一块只能映射到Cache的唯一一行。
        - 全相联映射：主存任意一块可映射到Cache的任意一行。
        - 组相联映射：主存每一块可映射到Cache的某一组内的任意一行。
        - 主存地址与Cache行、内容的对应关系因映射方式不同而不同。
        - Cache容量计算需区分数据区、标记、有效位等。

    2. Cache访问与相联存储器的关系：
        - 直接映射Cache按地址查找行。
        - 全相联映射Cache用多个比较器同时比对标记。
        - 组相联映射先按地址定位组，再组内并行比对标记。
        - 相联存储器的原理被用于全相联和组相联Cache的查找。

    3. **替换算法与写策略**：
        - 全相联和组相联映射需要替换算法，常用的有先进先出（FIFO）和最近最少用（LRU）。
        - 写策略包括写直达（write-through）和写回（write-back），命中和未命中时的处理方式不同。

4. **`虚拟存储器`**

    1. **虚拟存储器的基本思想与分页机制**：
        - 虚拟存储器通过分页机制实现程序地址空间与物理内存的分离。
        - 页（虚页、逻辑页）是虚拟空间的基本单位，页框（实页、物理页）是物理内存的基本单位。
        - 逻辑地址（虚拟地址）由CPU生成，物理地址（主存地址）由存储管理部件转换得到。
        - 虚拟存储器机制由硬件和操作系统协作实现，地址转换由硬件完成，缺页处理由操作系统完成。
        - 页表由操作系统管理维护。
        - 页的大小远大于Cache块，便于减少缺页次数和管理开销。
        - 页框与虚拟页之间采用全相联映射，便于灵活分配和高效利用内存。
        - 一致性问题采用回写（write back）方式，减少写操作次数。

    2. **页表的基本结构**：
        - 页表项包含装入位（表示该页是否在主存）、修改位（表示该页是否被修改）、存放位置（主存或外存地址）。
        - 页表项中没有虚页号，因为虚页号由页表索引隐含给出。
        - 可通过装入位和修改位区分未分配页、已分配的缓存页和已分配的未缓存页。

    3. **快表（TLB）的作用与结构**：
        - 快表（TLB）存储在CPU内部，属于高速缓存。
        - 采用快表的目的是加速虚拟地址到物理地址的转换。
        - TLB与页表之间一般采用组相联或全相联映射。
        - TLB表项由页表项内容和标记（tag）组成，全相联映射下标记为虚页号，组相联映射下标记为组号+虚页号。

    4. **虚拟地址访问存储单元的处理过程**：
        - CPU生成虚拟地址，先查TLB，若命中则直接得到物理地址，若未命中则查页表。
        - 物理地址用于访问Cache，若Cache命中则直接读写数据，若未命中则访问主存。
        - 若主存也未命中（缺页），则由操作系统将所需页从外存调入主存，更新页表和TLB后重试访问。

## 第八章：互连及输入输出组织

1. I/O系统及I/O设备

    1. I/O系统的性能指标包括吞吐率（I/O带宽）和响应时间。吞吐率指单位时间内I/O系统能传输的数据量，响应时间指从发出I/O请求到I/O操作完成所经历的时间。
    2. 外设的通用模型（抽象模型）包括主机接口、控制器、设备本体等部分。主机接口负责与主机通信，控制器负责管理和控制设备本体的具体操作，设备本体完成实际的数据读写。
    3. 磁盘上数据定位采用磁道号、磁头号、扇区号三元组。磁盘数据的存取以块（扇区）为单位。磁盘操作包括寻道操作（移动磁头到指定磁道）、旋转等待操作（等待目标扇区转到磁头下方）和读写操作（实际数据传输）。
    4. 低密度磁盘的各磁道扇区数相同，每个磁道存储的数据量相同，内磁道位密度高于外磁道。高密度磁盘各磁道位密度相同，外磁道扇区数多于内磁道，容量高于低密度磁盘。
    5. 磁盘容量分为未格式化容量和格式化容量。未格式化容量按物理参数计算，格式化容量为实际可用容量，需扣除管理信息。两者的计算方法不同。
    6. 硬盘的主要技术指标是平均存取时间T，计算公式为：T = 平均寻道时间 + 平均旋转等待时间 + 数据传输时间。
    7. 冗余磁盘阵列RAID的基本思想是将多个磁盘组合成一个逻辑磁盘，实现数据冗余和性能提升。RAID有数据分条、冗余存储和错误恢复三大特性。不同级别的RAID表示具有上述特性的不同设计结构。
    8. 固态硬盘SSD采用NAND闪存芯片作为存储介质，速度远快于传统磁盘。SSD以区块为单位进行写入和抹除，写操作比读操作慢。早期SSD接口与磁盘兼容，现代SSD多采用PCI-E或M.2接口，带宽更高。

2. 总线及系统互连、I/O接口

    1. 总线是连接各功能部件的数据传输通道。系统总线、通信总线、处理器总线、存储总线、I/O总线等按用途分类。总线宽度指总线一次可传输的数据位数，总线带宽指单位时间内可传输的数据量，总线工作频率指总线的时钟频率。FSB、QPI和PCI-Express x n总线各有特点，带宽计算方法依据总线宽度和频率。
    2. I/O接口的五大功能包括数据缓冲、数据格式转换、地址识别、状态控制和中断处理。I/O接口的通用结构包含数据寄存器、状态寄存器、控制寄存器、地址寄存器等，分别用于数据传输、状态指示、控制命令和地址识别。I/O端口是主机与外设通信的接口。
    3. I/O端口有独立编址和统一编址两种方式。独立编址将I/O端口与内存地址空间分开，统一编址将I/O端口映射到内存地址空间，便于统一管理和访问。

3. **`I/O数据传送控制方式`**

    1. 程序直接控制方式、程序中断方式和DMA方式是三种常见I/O数据传送方式。程序直接控制方式由CPU全程控制I/O，效率低；程序中断方式由外设中断CPU，CPU响应中断后进行数据传输，效率较高；DMA方式由DMA控制器直接管理数据传输，CPU只需发起和结束操作，效率最高。
    2. 中断是外设向CPU发出服务请求的机制。中断与异常的区别在于中断由外部事件引发，异常由程序执行错误引发。中断过程包括中断响应（CPU保存现场并转向中断服务程序）和中断处理（完成I/O操作并恢复现场）。单重中断只允许一个中断服务过程，多重中断允许中断嵌套，可通过中断优先级实现。
    3. 中断响应优先级决定CPU响应哪个中断请求，中断处理优先级决定中断服务程序的执行顺序。通过中断屏蔽字可调整中断处理优先级。
    4. DMA方式的基本要点是数据传输由DMA控制器完成，CPU只需发起和结束操作。DMA常用三种方式：CPU停止法（传输期间CPU暂停）、周期挪用法（DMA周期性占用总线）、交替分时访问法（CPU和DMA交替使用总线），各有优缺点。
    5. DMA控制器负责管理DMA传输，包括地址计数、数据缓冲和中断请求。DMA操作分为启动、传输和结束三个步骤。DMA I/O传送方式与中断I/O传输方式相比，DMA方式CPU干预少，效率更高，适合大批量数据传输。

## 第九章：并行处理系统

1. 并行处理系统涉及的主要技术问题包括互连结构的设计、数据一致性的维护、同步控制机制、计算任务的合理划分以及并行程序的设计方法等。
2. 并行处理系统的基本类型和相关概念包括：
   - SISD（单指令流单数据流）：传统的串行计算机结构。
   - SIMD（单指令流多数据流）：同一指令流控制多个处理单元并行处理不同数据，适合数据并行任务。
   - MIMD（多指令流多数据流）：多个处理单元可独立执行不同指令流，适合任务并行。
   - 多处理器系统：多个处理器共享主存和I/O资源，协同完成计算任务。
   - 多计算机系统：多个独立计算机通过网络互连协同工作。
   - 多处理器系统中的UMA（统一存储访问）：所有处理器访问主存的速度和方式相同。
   - NUMA（非统一存储访问）：不同处理器访问主存的速度和方式不同。
   - CC-NUMA（Cache一致性NUMA）：在NUMA基础上增加了缓存一致性机制。
   - 多计算机系统中的集群（Cluster）：通过高速网络将多台计算机组成的松散耦合系统。
   - 网格（Grid）：通过互联网将地理分布广泛的计算资源整合为虚拟超级计算机。
3. GPU芯片（卡）广泛应用于科学计算、人工智能、深度学习、图像处理、视频编解码、游戏渲染等领域，因其强大的并行计算能力成为高性能计算的重要平台。
4. 并行运算的类型包括：
   - 计算密集型：主要消耗CPU算力，数据量相对较小，瓶颈在计算资源。
   - 数据密集型：主要处理大量数据，瓶颈在数据的存储、传输和访问速度。
   - 数据密集与计算密集混合型：既需要大量数据处理，也需要大量计算资源。
5. 主要的并行处理程序设计方式包括：
   - 共享存储变量方式（多线程并行程序设计）：多个线程通过共享内存进行通信与协作，适合多核/多处理器系统。
   - 消息传递方式：各处理单元通过显式消息交换进行协作，适合分布式系统和多计算机系统。
   - MapReduce大规模并行计算框架：将大任务分解为Map和Reduce两个阶段，适合大数据处理和云计算环境。
   - CUDA并行编程模型：由NVIDIA提出，利用GPU进行大规模数据并行计算，适合科学计算和深度学习等领域。